#!/usr/bin/env python
# coding: utf-8
#
# Utility to create ATRAC3 RIFF files from EA3 files
# Parsing of EA3 is incomplete and assumes that the file
# was generated by atracdenc --encode=atrac3
#
# See https://github.com/GrapheneCt/ElevenMPV-A/blob/master/ElevenMPV-A/source/audio/at3.cpp for more complete parsing of EA3 files.
#
import argparse
import os
import struct


def dump_riff(riff):
    print('Dumping', riff)
    with open(riff, 'rb') as f:
        buf = f.read()
    if buf[:4] != b'RIFF':
        print('Not a RIFF File.')
        exit()
    _len = struct.unpack_from('<I', buf, 4)[0]
    if _len + 8 != os.stat(riff).st_size:
        print('RIFF Header length invalid. Was', _len, 'but expected', os.stat(riff).st_size - 8)
        exit()
    if buf[8:12] != b'WAVE':
        print('Not a RIFF/WAVE File.')
        exit()
    buf = buf[12:]
    while buf:
        _len = struct.unpack_from('<I', buf, 4)[0]
        _b = buf[8:8 + _len]
        if buf[:4] == b'fmt ':
            print('fmt : 0x%08x bytes' % _len)
            print('\tBytes', _b)
            print('\tCompression code: 0x%04x' % struct.unpack_from('<H', _b, 0)[0])
            print('\tNumber of channels: %d' % struct.unpack_from('<H', _b, 2)[0])
            print('\tSample rate: %d' % struct.unpack_from('<I', _b, 4)[0])
            print('\tAverage bytes per second: %d' % struct.unpack_from('<I', _b, 8)[0])
            print('\tBlock align: %d' % struct.unpack_from('<H', _b, 12)[0])
            print('\tSignificant bits per sample: %d' % struct.unpack_from('<H', _b, 14)[0])
            if len(_b[16:]) > 2:
                print('\tExtra format bytes: %d' % struct.unpack_from('<H', _b, 16)[0])
                print('\tExtra bytes', _b[18:])
        elif buf[:4] == b'data':
            print('data: 0x%08x bytes' % _len)
        elif buf[:4] == b'fact':
            print('fact: 0x%08x bytes' % _len)
            if _len == 4:
                print('\tdata', _b, '0x%08x' % struct.unpack_from('<I', _b, 0)[0])
            elif _len == 8:
                print('\tdata', _b, '0x%08x 0x%08x' % (struct.unpack_from('<I', _b, 0)[0], struct.unpack_from('<I', _b, 4)[0]))
        elif buf[:4] == b'smpl':
            print('smpl: 0x%08x bytes' % _len)
            print('\tdata', _b)
        elif buf[:4] == b'LIST':
            print('LIST: 0x%08x bytes' % _len)
            print('\tdata', _b)
        else:
            print('Unknown chunk type', buf[:4])
        _len = (_len + 1) & ~1  # chunks are 16 bit aligned
        buf = buf[8 + _len:]
    

def create_riff(ea3, riff, max_data_size=0):
    print('Create', riff, 'from', ea3)
    with open(riff, 'wb') as f:
        buf = bytearray(12)
        buf[:4] = b'RIFF'
        buf[8:12] = b'WAVE'
        f.write(buf)

        # fmt
        _b = bytearray(24)
        _b[:4] = b'fmt '
        struct.pack_into('<H', _b, 8, 0x270)  # compression code
        struct.pack_into('<H', _b, 10, 2)     # number of channels
        struct.pack_into('<I', _b, 12, 44100) # sample rate
        struct.pack_into('<I', _b, 16, 16537) # avg bytes per sec
        struct.pack_into('<H', _b, 20, 384)   # block align
        struct.pack_into('<H', _b, 22, 0)     # significant bits per sample
        _b = _b + b'\x0e\x00'
        _b = _b + b'\x01\x00\x00\x10\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00'
        struct.pack_into('<I', _b, 4, len(_b) - 8)
        f.write(_b)
            
        # data
        with open(ea3, 'rb') as d:
            buf = d.read()
            if buf[:4] != b'EA3\x01':
                print('Not a valid EA3 file', ea3, 'aborting.')
                exit()
            buf = buf[96:]
        if max_data_size and len(buf) > int(max_data_size):
            buf = buf[:int(max_data_size) & ~0x3f]
            print('Claming max size to', int(max_data_size) + ~0x3f)
        data_size = len(buf)
        _b = bytearray(8)
        _b[:4] = b'data'
        struct.pack_into('<I', _b, 4, data_size)
        buf = _b + buf
        if len(buf) & 1:
            buf = buf + b'\0'
        f.write(buf)
        
        # fact
        _b = bytearray(12)
        _b[:4] = b'fact'
        struct.pack_into('<I', _b, 4, len(_b) - 8)
        struct.pack_into('<I', _b, 8, int(data_size / 0xc0 * 0x201))
        f.write(_b)
        
        # LIST
        buf = b'ATRACDENC\0'
        _b = bytearray(4)
        struct.pack_into('<I', _b, 0, len(buf))
        buf = b'INFOISFT' + _b + buf
        _b = bytearray(4)
        struct.pack_into('<I', _b, 0, len(buf))
        buf = b'LIST' + _b + buf
        if len(buf) & 1:
            buf = buf + b'\0'
        f.write(buf)
        
        # update the RIFF length
        f.seek(0, 2)
        x = f.tell() - 8
        _b = bytearray(4)
        struct.pack_into('<I', _b, 0, x)
        f.seek(4)
        f.write(_b)
        
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('command', nargs=1, 
                        help='create|dump')
    parser.add_argument('--max-data-size',
                        help='Clamp the data chunk to this size')
    parser.add_argument('files', nargs='*', help='RIFF/WAVE file')
    args = parser.parse_args()

    if args.command[0] == 'dump':
        dump_riff(args.files[0])
    elif args.command[0] == 'create':
        if len(args.files) != 2:
            print('Usage: riff.py create FILE.EA3 FILE.AT3')
            exit()
        create_riff(args.files[0], args.files[1], args.max_data_size)
    else:
        print('No command given. Aborting')
    
